// -*- mode:c++ -*-

// Copyright (c) 2015 RISC-V Foundation
// Copyright (c) 2017 The University of Virginia
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Alec Roelke

////////////////////////////////////////////////////////////////////
//
// The RISC-V ISA decoder
//

decode QUADRANT default Unknown::unknown() {
//    0x0: decode COPCODE {
//    }
//    0x1: decode COPCODE {
//    }
//    0x2: decode COPCODE {
//    }

    0x0c: decode FUNCT3 {
        format ROp {
            0x0: decode FUNCT7 {
                0x0: add({{
                    Rp = Rs1_sd + Rs2_sd;
                }});
                0x1: mul({{
                    Rp = Rs1_sd*Rs2_sd;
                }}, IntMultOp);
                0x20: sub({{
                    Rp = Rs1_sd - Rs2_sd;
                }});
            }
            0x1: decode FUNCT7 {
                0x0: sll({{
                    Rp = Rs1 << Rs2<5:0>;
                }});
                0x1: mulh({{
                    bool negate = (Rs1_sd < 0) != (Rs2_sd < 0);

                    uint64_t Rs1_lo = (uint32_t)std::abs(Rs1_sd);
                    uint64_t Rs1_hi = (uint64_t)std::abs(Rs1_sd) >> 32;
                    uint64_t Rs2_lo = (uint32_t)std::abs(Rs2_sd);
                    uint64_t Rs2_hi = (uint64_t)std::abs(Rs2_sd) >> 32;

                    uint64_t hi = Rs1_hi*Rs2_hi;
                    uint64_t mid1 = Rs1_hi*Rs2_lo;
                    uint64_t mid2 = Rs1_lo*Rs2_hi;
                    uint64_t lo = Rs2_lo*Rs1_lo;
                    uint64_t carry = ((uint64_t)(uint32_t)mid1
                            + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                    uint64_t res = hi +
                                    (mid1 >> 32) +
                                    (mid2 >> 32) +
                                    carry;
                    Rp = negate ? ~res + (Rs1_sd*Rs2_sd == 0 ? 1 : 0)
                                : res;
                }}, IntMultOp);
            }
            0x2: decode FUNCT7 {
                0x0: slt({{
                    Rp = (Rs1_sd < Rs2_sd) ? 1 : 0;
                }});
                0x1: mulhsu({{
                    bool negate = Rs1_sd < 0;
                    uint64_t Rs1_lo = (uint32_t)std::abs(Rs1_sd);
                    uint64_t Rs1_hi = (uint64_t)std::abs(Rs1_sd) >> 32;
                    uint64_t Rs2_lo = (uint32_t)Rs2;
                    uint64_t Rs2_hi = Rs2 >> 32;

                    uint64_t hi = Rs1_hi*Rs2_hi;
                    uint64_t mid1 = Rs1_hi*Rs2_lo;
                    uint64_t mid2 = Rs1_lo*Rs2_hi;
                    uint64_t lo = Rs1_lo*Rs2_lo;
                    uint64_t carry = ((uint64_t)(uint32_t)mid1
                            + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                    uint64_t res = hi +
                                    (mid1 >> 32) +
                                    (mid2 >> 32) +
                                    carry;
                    Rp = negate ? ~res + (Rs1_sd*Rs2 == 0 ? 1 : 0) : res;
                }}, IntMultOp);
            }
            0x3: decode FUNCT7 {
                0x0: sltu({{
                    Rp = (Rs1 < Rs2) ? 1 : 0;
                }});
                0x1: mulhu({{
                    uint64_t Rs1_lo = (uint32_t)Rs1;
                    uint64_t Rs1_hi = Rs1 >> 32;
                    uint64_t Rs2_lo = (uint32_t)Rs2;
                    uint64_t Rs2_hi = Rs2 >> 32;

                    uint64_t hi = Rs1_hi*Rs2_hi;
                    uint64_t mid1 = Rs1_hi*Rs2_lo;
                    uint64_t mid2 = Rs1_lo*Rs2_hi;
                    uint64_t lo = Rs1_lo*Rs2_lo;
                    uint64_t carry = ((uint64_t)(uint32_t)mid1
                            + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                    Rp = hi + (mid1 >> 32) + (mid2 >> 32) + carry;
                }}, IntMultOp);
            }
            0x4: decode FUNCT7 {
                0x0: xor({{
                    Rp = Rs1 ^ Rs2;
                }});
                0x1: div({{
                    if (Rs2_sd == 0) {
                        Rp_sd = -1;
                    } else if (
                            Rs1_sd == std::numeric_limits<int64_t>::min()
                            && Rs2_sd == -1) {
                        Rp_sd = std::numeric_limits<int64_t>::min();
                    } else {
                        Rp_sd = Rs1_sd/Rs2_sd;
                    }
                }}, IntDivOp);
            }
            0x5: decode FUNCT7 {
                0x0: srl({{
                    Rp = Rs1 >> Rs2<5:0>;
                }});
                0x1: divu({{
                    if (Rs2 == 0) {
                        Rp = std::numeric_limits<uint64_t>::max();
                    } else {
                        Rp = Rs1/Rs2;
                    }
                }}, IntDivOp);
                0x20: sra({{
                    Rp_sd = Rs1_sd >> Rs2<5:0>;
                }});
            }
            0x6: decode FUNCT7 {
                0x0: or({{
                    Rp = Rs1 | Rs2;
                }});
                0x1: rem({{
                    if (Rs2_sd == 0) {
                        Rp = Rs1_sd;
                    } else if (
                            Rs1_sd == std::numeric_limits<int64_t>::min()
                            && Rs2_sd == -1) {
                        Rp = 0;
                    } else {
                        Rp = Rs1_sd%Rs2_sd;
                    }
                }}, IntDivOp);
            }
            0x7: decode FUNCT7 {
                0x0: and({{
                    Rp = Rs1 & Rs2;
                }});
                0x1: remu({{
                    if (Rs2 == 0) {
                        Rp = Rs1;
                    } else {
                        Rp = Rs1%Rs2;
                    }
                }}, IntDivOp);
            }
        }
    }

}
