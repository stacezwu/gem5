// -*- mode:c++ -*-

// Copyright (c) 2015 RISC-V Foundation
// Copyright (c) 2017 The University of Virginia
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Alec Roelke

////////////////////////////////////////////////////////////////////
//
// The RISC-V ISA decoder
//

decode QUADRANT default Unknown::unknown() {
//    0x0: decode COPCODE {
//    }
//    0x1: decode COPCODE {
//    }
//    0x2: decode COPCODE {
//    }

    0x3: decode OPCODE {

        0x00: decode FUNCT3 {
            format Load {
                0x0: lb({{
                    Rp_sd = Mem_sb;
                }});
                0x1: lh({{
                    Rp_sd = Mem_sh;
                }});
                0x2: lw({{
                    Rp_sd = Mem_sw;
                }});
                0x3: ld({{
                    Rp_sd = Mem_sd;
                }});
                0x4: lbu({{
                    Rp = Mem_ub;
                }});
                0x5: lhu({{
                    Rp = Mem_uh;
                }});
                0x6: lwu({{
                    Rp = Mem_uw;
                }});
            }
        }

        0x03: decode FUNCT3 {
            format FenceOp {
                0x0: fence({{
                }}, uint64_t, IsReadBarrier, IsWriteBarrier, No_OpClass);
                0x1: fence_i({{
                }}, uint64_t, IsNonSpeculative, IsSerializeAfter, No_OpClass);
            }
        }

        
        0x04: decode FUNCT3 {
            format IOp {
                0x0: addi({{
                    Rp = Rs1_sd + imm;
                }});
                0x1: slli({{
                    Rp = Rs1 << imm;
                }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                0x2: slti({{
                    Rp = (Rs1_sd < imm) ? 1 : 0;
                }});
                0x3: sltiu({{
                    Rp = (Rs1 < imm) ? 1 : 0;
                }}, uint64_t);
                0x4: xori({{
                    Rp = Rs1 ^ imm;
                }}, uint64_t);
                0x5: decode SRTYPE {
                    0x0: srli({{
                        Rp = Rs1 >> imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                    0x1: srai({{
                        Rp_sd = Rs1_sd >> imm;
                    }}, imm_type = uint64_t, imm_code = {{ imm = SHAMT6; }});
                }
                0x6: ori({{
                    Rp = Rs1 | imm;
                }}, uint64_t);
                0x7: andi({{
                    Rp = Rs1 & imm;
                }}, uint64_t);
            }
        }
        
        0x05: UOp::auipc({{
            Rp = PC + (sext<20>(imm) << 12);
        }});

        0x08: decode FUNCT3 {
            format Store {
                0x0: sb({{
                    Mem_ub = Rs2_ub;
                }});
                0x1: sh({{
                    Mem_uh = Rs2_uh;
                }});
                0x2: sw({{
                    Mem_uw = Rs2_uw;
                }});
                0x3: sd({{
                    Mem_ud = Rs2_ud;
                }});
            }
        }
        
        0x0c: decode FUNCT3 {
            format ROp {
                0x0: decode FUNCT7 {
                    0x0: add({{
                        Rp = Rs1_sd + Rs2_sd;
                    }});
                    0x1: mul({{
                        Rp = Rs1_sd*Rs2_sd;
                    }}, IntMultOp);
                    0x20: sub({{
                        Rp = Rs1_sd - Rs2_sd;
                    }});
                }
                0x1: decode FUNCT7 {
                    0x0: sll({{
                        Rp = Rs1 << Rs2<5:0>;
                    }});
                    0x1: mulh({{
                        bool negate = (Rs1_sd < 0) != (Rs2_sd < 0);

                        uint64_t Rs1_lo = (uint32_t)std::abs(Rs1_sd);
                        uint64_t Rs1_hi = (uint64_t)std::abs(Rs1_sd) >> 32;
                        uint64_t Rs2_lo = (uint32_t)std::abs(Rs2_sd);
                        uint64_t Rs2_hi = (uint64_t)std::abs(Rs2_sd) >> 32;

                        uint64_t hi = Rs1_hi*Rs2_hi;
                        uint64_t mid1 = Rs1_hi*Rs2_lo;
                        uint64_t mid2 = Rs1_lo*Rs2_hi;
                        uint64_t lo = Rs2_lo*Rs1_lo;
                        uint64_t carry = ((uint64_t)(uint32_t)mid1
                                + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                        uint64_t res = hi +
                                        (mid1 >> 32) +
                                        (mid2 >> 32) +
                                        carry;
                        Rp = negate ? ~res + (Rs1_sd*Rs2_sd == 0 ? 1 : 0)
                                    : res;
                    }}, IntMultOp);
                }
                0x2: decode FUNCT7 {
                    0x0: slt({{
                        Rp = (Rs1_sd < Rs2_sd) ? 1 : 0;
                    }});
                    0x1: mulhsu({{
                        bool negate = Rs1_sd < 0;
                        uint64_t Rs1_lo = (uint32_t)std::abs(Rs1_sd);
                        uint64_t Rs1_hi = (uint64_t)std::abs(Rs1_sd) >> 32;
                        uint64_t Rs2_lo = (uint32_t)Rs2;
                        uint64_t Rs2_hi = Rs2 >> 32;

                        uint64_t hi = Rs1_hi*Rs2_hi;
                        uint64_t mid1 = Rs1_hi*Rs2_lo;
                        uint64_t mid2 = Rs1_lo*Rs2_hi;
                        uint64_t lo = Rs1_lo*Rs2_lo;
                        uint64_t carry = ((uint64_t)(uint32_t)mid1
                                + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                        uint64_t res = hi +
                                        (mid1 >> 32) +
                                        (mid2 >> 32) +
                                        carry;
                        Rp = negate ? ~res + (Rs1_sd*Rs2 == 0 ? 1 : 0) : res;
                    }}, IntMultOp);
                }
                0x3: decode FUNCT7 {
                    0x0: sltu({{
                        Rp = (Rs1 < Rs2) ? 1 : 0;
                    }});
                    0x1: mulhu({{
                        uint64_t Rs1_lo = (uint32_t)Rs1;
                        uint64_t Rs1_hi = Rs1 >> 32;
                        uint64_t Rs2_lo = (uint32_t)Rs2;
                        uint64_t Rs2_hi = Rs2 >> 32;

                        uint64_t hi = Rs1_hi*Rs2_hi;
                        uint64_t mid1 = Rs1_hi*Rs2_lo;
                        uint64_t mid2 = Rs1_lo*Rs2_hi;
                        uint64_t lo = Rs1_lo*Rs2_lo;
                        uint64_t carry = ((uint64_t)(uint32_t)mid1
                                + (uint64_t)(uint32_t)mid2 + (lo >> 32)) >> 32;

                        Rp = hi + (mid1 >> 32) + (mid2 >> 32) + carry;
                    }}, IntMultOp);
                }
                0x4: decode FUNCT7 {
                    0x0: xor({{
                        Rp = Rs1 ^ Rs2;
                    }});
                    0x1: div({{
                        if (Rs2_sd == 0) {
                            Rp_sd = -1;
                        } else if (
                                Rs1_sd == std::numeric_limits<int64_t>::min()
                                && Rs2_sd == -1) {
                            Rp_sd = std::numeric_limits<int64_t>::min();
                        } else {
                            Rp_sd = Rs1_sd/Rs2_sd;
                        }
                    }}, IntDivOp);
                }
                0x5: decode FUNCT7 {
                    0x0: srl({{
                        Rp = Rs1 >> Rs2<5:0>;
                    }});
                    0x1: divu({{
                        if (Rs2 == 0) {
                            Rp = std::numeric_limits<uint64_t>::max();
                        } else {
                            Rp = Rs1/Rs2;
                        }
                    }}, IntDivOp);
                    0x20: sra({{
                        Rp_sd = Rs1_sd >> Rs2<5:0>;
                    }});
                }
                0x6: decode FUNCT7 {
                    0x0: or({{
                        Rp = Rs1 | Rs2;
                    }});
                    0x1: rem({{
                        if (Rs2_sd == 0) {
                            Rp = Rs1_sd;
                        } else if (
                                Rs1_sd == std::numeric_limits<int64_t>::min()
                                && Rs2_sd == -1) {
                            Rp = 0;
                        } else {
                            Rp = Rs1_sd%Rs2_sd;
                        }
                    }}, IntDivOp);
                }
                0x7: decode FUNCT7 {
                    0x0: and({{
                        Rp = Rs1 & Rs2;
                    }});
                    0x1: remu({{
                        if (Rs2 == 0) {
                            Rp = Rs1;
                        } else {
                            Rp = Rs1%Rs2;
                        }
                    }}, IntDivOp);
                }
            }
        }
        
        0x0d: UOp::lui({{
            Rp = (uint64_t)(sext<20>(imm) << 12);
        }});


        0x18: decode FUNCT3 {
            format BOp {
                0x0: beq({{
                    if (Rs1 == Rs2) {
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x1: bne({{
                    if (Rs1 != Rs2) {
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x4: blt({{
                    if (Rs1_sd < Rs2_sd) {
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x5: bge({{
                    if (Rs1_sd >= Rs2_sd) {
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x6: bltu({{
                    if (Rs1 < Rs2) {
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
                0x7: bgeu({{
                    if (Rs1 >= Rs2) {
                        NPC = PC + imm;
                    } else {
                        NPC = NPC;
                    }
                }}, IsDirectControl, IsCondControl);
            }
        }

        0x19: decode FUNCT3 {
            0x0: Jump::jalr({{
                Rp = NPC;
                NPC = (imm + Rs1) & (~0x1);
            }}, IsIndirectControl, IsUncondControl, IsCall);
        }

        0x1b: JOp::jal({{
            Rp = NPC;
            NPC = PC + imm;
        }}, IsDirectControl, IsUncondControl, IsCall);

        0x1c: decode FUNCT3 {
            format SystemOp {
                0x0: decode FUNCT7 {
                    0x0: decode RS2 {
                        0x0: ecall({{
                            return std::make_shared<SyscallFault>(
                                (PrivilegeMode)xc->readMiscReg(MISCREG_PRV));
                        }}, IsSerializeAfter, IsNonSpeculative, IsSyscall,
                            No_OpClass);
                    }
                }
            }
        }
    }

}
